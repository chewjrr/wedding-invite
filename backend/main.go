package main

import (
	"bufio"
	"log"
	"net/http"
	"os"
	"strings"

	"wedding-backend/internal/database"
	"wedding-backend/internal/handlers"
)

// loadEnv –∑–∞–≥—Ä—É–∂–∞–µ—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–∑ .env, –µ—Å–ª–∏ —Ñ–∞–π–ª —Å—É—â–µ—Å—Ç–≤—É–µ—Ç (–¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–π —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏)
func loadEnv() {
	if _, err := os.Stat(".env"); os.IsNotExist(err) {
		log.Println("‚ö†Ô∏è –§–∞–π–ª .env –Ω–µ –Ω–∞–π–¥–µ–Ω ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è (–Ω–∞–ø—Ä–∏–º–µ—Ä, –Ω–∞ Render)")
		return
	}

	file, err := os.Open(".env")
	if err != nil {
		log.Printf("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å .env: %v", err)
		return
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" || strings.HasPrefix(line, "#") || !strings.Contains(line, "=") {
			continue
		}

		parts := strings.SplitN(line, "=", 2)
		key := strings.TrimSpace(parts[0])
		value := strings.TrimSpace(parts[1])

		// –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –µ—â—ë –Ω–µ –∑–∞–¥–∞–Ω–∞ (—á—Ç–æ–±—ã –Ω–µ –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∞—Ç—å env –Ω–∞ Render)
		if os.Getenv(key) == "" {
			os.Setenv(key, value)
		}
	}

	log.Println("‚úÖ –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–∑ .env –∑–∞–≥—Ä—É–∂–µ–Ω—ã")
}

// getPort –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–æ—Ä—Ç –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –æ–∫—Ä—É–∂–µ–Ω–∏—è –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç 8080 –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
func getPort() string {
	if p := os.Getenv("PORT"); p != "" {
		return p
	}
	return "8080"
}

// withCORS –¥–æ–±–∞–≤–ª—è–µ—Ç –∑–∞–≥–æ–ª–æ–≤–∫–∏ CORS
func withCORS(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// –†–∞–∑—Ä–µ—à–∞–µ–º –≤—Å–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏ (–¥–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã). –í –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ –º–æ–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –¥–æ–º–µ–Ω.
		w.Header().Set("Access-Control-Allow-Origin", "*")
		w.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
		w.Header().Set("Access-Control-Allow-Headers", "Content-Type")

		// –î–ª—è preflight-–∑–∞–ø—Ä–æ—Å–æ–≤
		if r.Method == "OPTIONS" {
			w.WriteHeader(http.StatusOK)
			return
		}

		next.ServeHTTP(w, r)
	})
}

func main() {
	// –ó–∞–≥—Ä—É–∂–∞–µ–º .env —Ç–æ–ª—å–∫–æ –¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–π —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
	loadEnv()

	// –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∑–∞–¥–∞–Ω –ª–∏ DATABASE_URL
	dbURL := os.Getenv("DATABASE_URL")
	if dbURL == "" {
		log.Fatal("‚ùå –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è DATABASE_URL –Ω–µ –∑–∞–¥–∞–Ω–∞. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –æ–Ω–∞ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –≤ .env –∏–ª–∏ –Ω–∞ Render.")
	}

	// –ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ –ë–î
	database.Connect()
	defer database.Close()

	// –°–æ–∑–¥–∞—ë–º —Ç–∞–±–ª–∏—Ü—É –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
	database.Migrate()

	// –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –º–∞—Ä—à—Ä—É—Ç–æ–≤
	mux := http.NewServeMux()
	mux.HandleFunc("/api/wishes", handlers.GetWishes)
	mux.HandleFunc("/api/wish", handlers.AddWish)
	mux.HandleFunc("/telegram", handlers.HandleWebhook)

	// –î–æ–±–∞–≤–ª—è–µ–º CORS
	handler := withCORS(mux)

	// –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–æ—Ä—Ç
	port := getPort()

	// –õ–æ–≥–∏—Ä—É–µ–º —Å—Ç–∞—Ä—Ç —Å–µ—Ä–≤–µ—Ä–∞
	log.Printf("üöÄ –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ :%s", port)
	log.Printf("üîó DATABASE_URL: %s", redactDBURL(dbURL)) // –º–∞—Å–∫–∏—Ä—É–µ–º –ø–∞—Ä–æ–ª—å –≤ –ª–æ–≥–∞—Ö

	// –ó–∞–ø—É—Å–∫ HTTP-—Å–µ—Ä–≤–µ—Ä–∞
	if err := http.ListenAndServe(":"+port, handler); err != nil {
		log.Fatalf("‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: %v", err)
	}
}

// redactDBURL —Å–∫—Ä—ã–≤–∞–µ—Ç –ø–∞—Ä–æ–ª—å –≤ —Å—Ç—Ä–æ–∫–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –≤ –ª–æ–≥–∞—Ö
func redactDBURL(url string) string {
	start := strings.Index(url, "://")
	if start == -1 {
		return url
	}
	at := strings.Index(url[start:], "@")
	if at == -1 {
		return url
	}
	end := start + at
	return url[:end] + "@***:***@" + url[strings.Index(url[end:], "@")+end+1:]
}
